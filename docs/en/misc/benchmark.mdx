# Benchmark

To run this benchmark yourself, clone [web-infra-dev/bundler-benchmark](https://github.com/web-infra-dev/bundler-benchmark) and then use this command from the root:

```bash
./scripts/bench-all.sh ${platform}
# `platform` is used to uniquely identify the generated benchmark data.
```

## Benchmark case

### all

This project is used for us to compare development and production build performance.
This project is a combination of `atlaskit-editor`, `common-libs`, `common-libs-chunks`, `rome`, `esbuild-three`

here is the simple description of each sub project:

**atlaskit-editor**

Basic react application with `@atlaskit/editor-core`

**common-libs**

A combination of some widely used libraries in Javascript ecosystem.

**common-libs-chunks**

Same as `common-libs`, but using async `import()` syntax to force bundler generate multiple chunks.

**esbuild-three**

A large JavaScript codebase by duplicating the three.js library 10 times.

**rome**

The old Rome code base (prior to their Rust rewrite) to approximate a large TypeScript codebase.

### react-components-10000

10000 react components (each component only have basic skeleton) to test hot module replacement performance of each devServer of bundler.

## Metrics

- dev-cold-start: the time it takes for the development build to complete without caching.
- production-build-cold-start: the time it takes for the production build to complete without caching.
- HMR: the time it takes for the development server rebuild the project when an update is applied to a source file.
  **there is two sub metrics of HMR**:
  - leaf: time for updating a react component file that has no dependency
  - root: time for updating a root react component, normally it is named `App.tsx` or `index.tsx`

## Bundler involved in comparison

- webpack + ts-loader (or babel-loader in react-components-10000) + terser-webpack-plugin

- webpack + swc-loader + swc-minifier

- rspack(using swc as transpiler and swc minifier)

All the configuration in development mode keep as is except the loader which dependends on the test target.
In production mode we set `devtool` to `source-map` and use loader and minifier dependends on the test target, keep other configuration as is.

## Methodology

### dev-cold-start

Using `hyperfine` to run each development build command 10 times with warmup and get the average time and generate corresponding markdown table.

### production-cold-start

Using `hyperfine` to run each production build command 10 times with warmup and get the average time and generate corresponding markdown table.

### HMR

The HMR benchmark is relatively complex because it is usually implemented in four stages.

1. devServer listens for file changes and rebuilds the project (usually a partial build).
2. devServer sends the built diff to the HMR client over the local network (usually a websocket).
3. HMR client receives the diff and applies the diff to runtime code of the browser.
4. the browser rerendering the view.

Sometimes the 2~4 stages cost about half time of the HMR, for better comparing the incremental rebuild performance of each bundler, we only measure the first stage.
We using the rebuild time generated by each bundler.
