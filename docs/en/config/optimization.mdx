import PropertyType from '../../../components/property-type.tsx';

# Optimization

Rspack will select appropriate optimization configuration based on the [`mode`](/config/mode). You can also customize the configuration via [`optimization`](/config/optimization).

## optimization.removeAvailableModules

<PropertyType type="boolean" defaultValueList={[{ defaultValue: 'true' }]} />

A module can be removed from a Chunk if the module have been included in all of its parent Chunks.

```
EntryChunk(index.js, a.js, b.js)
                                  \
                                  ChunkFoo(b.js, c.js)
                                  /
EntryChunk2(index.js, a.js, b.js)
```

In the above example, `b.js` has already been included in `EntryChunk` and `EntryChunk2`, so `b.js` can be removed from `ChunkFoo`.

:::info Inconsistent behaviors with Webpack

- [Webpack](https://webpack.js.org/configuration/optimization/#optimizationremoveavailablemodules) only enable this optimization in `production` mode.

:::

## optimization.moduleIds

<PropertyType type="'named' | 'deterministic'" />

| option          | description                                                                                                                        |
| --------------- | ---------------------------------------------------------------------------------------------------------------------------------- |
| `named`         | Use meaningful, easy-to-debug content as id. This option is enabled by default in development mode                                 |
| `deterministic` | Use the hashed module identifier as the id to benefit from long-term caching. This option is enabled by default in production mode |

## optimization.minimize

<PropertyType type="boolean" />

- **Default:** `true` (development mode)
- **Default:** `false` (production mode)

Whether to minimize the bundle.

## optimization.minimizer

Customize the minimizer. When using a custom minimizer, the built-in minimizer will be disabled.

```js
const minifyPlugin = require("@rspack/plugin-minify");
module.exports = {
	context: __dirname,
	target: "node",
	entry: {
		main: "./index.js"
	},
	optimization: {
		minimize: true,
		minimizer: [new minifyPlugin(
          minifier: "terser"
        )]
	}
};
```

## optimization.removeEmptyChunks

<PropertyType type="boolean" defaultValueList={[{ defaultValue: 'true' }]} />

Remove empty chunks generated in the compilation.

## optimization.runtimeChunk

<PropertyType type="boolean" defaultValueList={[{ defaultValue: 'true' }]} />

## optimization.sideEffects

<PropertyType
  type="boolean | 'flag'"
  defaultValueList={[
    { defaultValue: 'true', mode: '(production mode)' },
    { defaultValue: 'false', mode: '(development mode)' },
  ]}
/>

```json
{
  "name": "npm module",
  "version": "1.0.0",
  "sideEffects": ["**/src/*.js"]
}
```

Tells rspack to recognise the sideEffects flag in package.json or rules to skip over modules which are flagged to contain no side effects when exports are not used.

`optimization.sideEffects` dependends on `builtins.treeShaking` to be enabled.
This configuration has a build time cost, but eliminating modules has positive impact on performance because of less code generation. Effect of this optimization depends on your codebase.

**rspack.config.js**

```js
module.exports = {
  //...
  optimization: {
    sideEffects: true,
  },
};
```

If you only want rspack use the manual `sideEffects` flag via (package.json and module.rule.sideEffects) and don't analyse code:

**rspack.config.js**

```js
module.exports = {
  //...
  optimization: {
    sideEffects: 'flag',
  },
};
```

:::info Tip
When `optimization.sideEffects` is true , rspack will also flag modules as side effect free when they contain only side effect free statements.
:::

## optimization.splitChunks

Rspack supports you to split Chunk with the `optimization.splitChunks` configuration item.

### Default:

Out of the box `SplitChunksPlugin` should work well for most users.

By default it only affects on-demand chunks, because changing initial chunks would affect the script tags the HTML file should include to run the project.

Webpack will automatically split chunks based on these conditions:

- New chunk can be shared OR modules are from the node_modules folder
- New chunk would be bigger than 20kb (before min+gz)
- Maximum number of parallel requests when loading chunks on demand would be lower or equal to 30
- Maximum number of parallel requests at initial page load would be lower or equal to 30

When trying to fulfill the last two conditions, bigger chunks are preferred.

### Configuration

rspack provides a set of options for developers that want more control over this functionality.

:::warning

The default configuration was chosen to fit web performance best practices, but the optimal strategy for your project might differ. If you're changing the configuration, you should measure the effect of your changes to ensure there's a real benefit.

:::

### optimization.splitChunks

This configuration object represents the default behavior of the `SplitChunksPlugin`.

```js title=rspack.config.js
module.exports = {
  //...
  optimization: {
    splitChunks: {
      chunks: 'async',
      minSize: 20000,
      minRemainingSize: 0,
      minChunks: 1,
      maxAsyncRequests: 30,
      maxInitialRequests: 30,
      enforceSizeThreshold: 50000,
      cacheGroups: {
        defaultVendors: {
          test: /[\\/]node_modules[\\/]/,
          priority: -10,
          reuseExistingChunk: true,
        },
        default: {
          minChunks: 2,
          priority: -20,
          reuseExistingChunk: true,
        },
      },
    },
  },
};
```

:::warning

When files paths are processed by webpack, they always contain `/` on UNIX systems and `\` on Windows. That's why using `[\\/]` in `{cacheGroup}.test` fields is necessary to represent a path separator. `/` or `\` in `{cacheGroup}.test` will cause issues when used cross-platform.

:::

:::warning

Since webpack 5, passing an entry name to `{cacheGroup}.test` and using a name of an existing chunk for `{cacheGroup}.name` is no longer allowed.

:::

### splitChunks.automaticNameDelimiter

By default webpack will generate names using origin and name of the chunk (e.g. `vendors~main.js`). This option lets you specify the delimiter to use for the generated names.

- **Type:** `string`
- **Default:：** `'~'`

### splitChunks.chunks

- **Type:** `string | (chunk: Chunk) => boolean`
- **Default:：** `'~'`

This indicates which chunks will be selected for optimization. When a string is provided, valid values are `all`, `async`, and `initial`. Providing `all` can be particularly powerful, because it means that chunks can be shared even between async and non-async chunks.

```js title=rspack.config.js
module.exports = {
  //...
  optimization: {
    splitChunks: {
      // include all types of chunks
      chunks: 'all',
    },
  },
};
```

Alternatively, you may provide a function for more control. The return value will indicate whether to include each chunk.

```js title=rspack.config.js
module.exports = {
  //...
  optimization: {
    splitChunks: {
      chunks(chunk) {
        // exclude `my-excluded-chunk`
        return chunk.name !== 'my-excluded-chunk';
      },
    },
  },
};
```

### splitChunks.maxAsyncRequests

- **Type:** `number`
- **Default:：** `30`

Maximum number of parallel requests when on-demand loading.

### splitChunks.maxInitialRequests

- **Type:** `number`
- **Default:：** `30`

Maximum number of parallel requests at an entry point.

### splitChunks.defaultSizeTypes

- **Type:** `string[]`
- **Default:：** `['javascript', 'unknown']`

Sets the size types which are used when a number is used for sizes.

### splitChunks.minChunks

- **Type:** `number`
- **Default:：** `1`

The minimum times must a module be shared among chunks before splitting.

### splitChunks.minSize

- **Type:** `number`
- **Default:：** `20000`

Minimum size, in bytes, for a chunk to be generated.

### splitChunks.minSizeReduction

- **Type:** `number`

Minimum size reduction to the main chunk (bundle), in bytes, needed for a chunk to be generated. Meaning if splitting into a chunk does not reduce the size of the main chunk (bundle) by the given amount of bytes, it won't be split, even if it meets the `splitChunks.minSize` value.

:::info

Both `splitChunks.minSizeReduction` and `splitChunks.minSize` need to be fulfilled for a chunk to be generated.

:::

### splitChunks.enforceSizeThreshold

#### splitChunks.cacheGroups.\{cacheGroup\}.enforceSizeThreshold

- **Type:** `number`
- **Default:：** `50000`

Size threshold at which splitting is enforced and other restrictions (minRemainingSize, maxAsyncRequests, maxInitialRequests) are ignored.

### splitChunks.minRemainingSize

#### splitChunks.cacheGroups.\{cacheGroup\}.minRemainingSize

- **Type:** `number`
- **Default:：** `0`

`splitChunks.minRemainingSize` option was introduced in webpack 5 to avoid zero sized modules by ensuring that the minimum size of the chunk which remains after splitting is above a limit. Defaults to `0` in ['development' mode](/config/mode). For other cases `splitChunks.minRemainingSize` defaults to the value of `splitChunks.minSize` so it doesn't need to be specified manually except for the rare cases where deep control is required.

:::warning

`splitChunks.minRemainingSize` only takes effect when a single chunk is remaining.

:::

### splitChunks.maxSize

- **Type:** `number`
- **Default:：** `0`

Using `maxSize` (either globally `optimization.splitChunks.maxSize` per cache group `optimization.splitChunks.cacheGroups[x].maxSize` or for the fallback cache group `optimization.splitChunks.fallbackCacheGroup.maxSize`) tells webpack to try to split chunks bigger than `maxSize` bytes into smaller parts. Parts will be at least `minSize` (next to `maxSize`) in size.
The algorithm is deterministic and changes to the modules will only have local effects. So that it is usable when using long term caching and doesn't require records. `maxSize` is only a hint and could be violated when modules are bigger than `maxSize` or splitting would violate `minSize`.

When the chunk has a name already, each part will get a new name derived from that name. Depending on the value of `optimization.splitChunks.hidePathInfo` it will add a key derived from the first module name or a hash of it.

`maxSize` option is intended to be used with HTTP/2 and long term caching. It increases the request count for better caching. It could also be used to decrease the file size for faster rebuilding.

:::info

`maxSize` takes higher priority than `maxInitialRequest/maxAsyncRequests`. Actual priority is `maxInitialRequest/maxAsyncRequests < maxSize < minSize`.

:::

:::info

Setting the value for `maxSize` sets the value for both `maxAsyncSize` and `maxInitialSize`.

:::

### splitChunks.maxAsyncSize

- **Type:** `number`

Like `maxSize`, `maxAsyncSize` can be applied globally (`splitChunks.maxAsyncSize`), to cacheGroups (`splitChunks.cacheGroups.{cacheGroup}.maxAsyncSize`), or to the fallback cache group (`splitChunks.fallbackCacheGroup.maxAsyncSize`).

The difference between `maxAsyncSize` and `maxSize` is that `maxAsyncSize` will only affect on-demand loading chunks.

### splitChunks.maxInitialSize

- **Type:** `number`

Like `maxSize`, `maxInitialSize` can be applied globally (`splitChunks.maxInitialSize`), to cacheGroups (`splitChunks.cacheGroups.{cacheGroup}.maxInitialSize`), or to the fallback cache group (`splitChunks.fallbackCacheGroup.maxInitialSize`).

The difference between `maxInitialSize` and `maxSize` is that `maxInitialSize` will only affect initial load chunks.

### splitChunks.name

- **Type:** `boolean: (module, chunks, cacheGroupKey) => string`
- **Default:：** `false`

Also available for each cacheGroup: `splitChunks.cacheGroups.{cacheGroup}.name`.

The name of the split chunk. Providing `false` will keep the same name of the chunks so it doesn't change names unnecessarily. It is the recommended value for production builds.

Providing a string or a function allows you to use a custom name. Specifying either a string or a function that always returns the same string will merge all common modules and vendors into a single chunk. This might lead to bigger initial downloads and slow down page loads.

If you choose to specify a function, you may find the `chunk.name` property (where `chunk` is an element of the `chunks` array) particularly useful in choosing a name for your chunk.

If the `splitChunks.name` matches an [entry point](/config/entry) name, the entry point will be removed.

:::info

`splitChunks.cacheGroups.{cacheGroup}.name` can be used to move modules into a chunk that is a parent of the source chunk. For example, use `name: "entry-name"` to move modules into the `entry-name` chunk. You can also use on demand named chunks, but you must be careful that the selected modules are only used under this chunk.

:::

### splitChunks.cacheGroups

Cache groups can inherit and/or override any options from `splitChunks.*`; but `test`, `priority` and `reuseExistingChunk` can only be configured on cache group level. To disable any of the default cache groups, set them to `false`.

```js title=webpack.config.js
module.exports = {
  //...
  optimization: {
    splitChunks: {
      cacheGroups: {
        default: false,
      },
    },
  },
};
```

#### splitChunks.cacheGroups.\{cacheGroup\}.priority

- **Type:** `number`
- **Default:：** `-20`

A module can belong to multiple cache groups. The optimization will prefer the cache group with a higher `priority`. The default groups have a negative priority to allow custom groups to take higher priority (default value is `0` for custom groups).

#### splitChunks.cacheGroups.\{cacheGroup\}.reuseExistingChunk

- **Type:** `boolean`
- **Default:：** `true`

If the current chunk contains modules already split out from the main bundle, it will be reused instead of a new one being generated. This can affect the resulting file name of the chunk.

#### splitChunks.cacheGroups.\{cacheGroup\}.type

- **Type:** `string`

Allows to assign modules to a cache group by module type.

#### splitChunks.cacheGroups.\{cacheGroup\}.test

- **Type:** `RegExp | string`

Controls which modules are selected by this cache group. Omitting it selects all modules. It can match the absolute module resource path or chunk names. When a chunk name is matched, all modules in the chunk are selected.

#### splitChunks.cacheGroups.\{cacheGroup\}.enforce

- **Type:** `boolean`
- **Default:：** `false`

Tells webpack to ignore `splitChunks.minSize`, `splitChunks.minChunks`, `splitChunks.maxAsyncRequests` and `splitChunks.maxInitialRequests` options and always create chunks for this cache group.

#### splitChunks.cacheGroups.\{cacheGroup\}.idHint

- **Type:** `string`

Sets the hint for chunk id. It will be added to chunk's filename.
