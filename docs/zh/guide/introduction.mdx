import compare from '../../public/compare.png';

# 介绍

Rspack 是一个基于 Rust 的高性能构建引擎，提供与 Webpack 生态系统的强大互操作性和低成本集成，从而实现更好的性能和两个工具之间的高效联动。

## 为什么选择 Rspack

我们创建 Rspack 是为了解决我们在 ByteDance 维护公司构建工具时遇到的各种性能问题，并且市面上并没有工具能够良好的解决这些问题。

### 和 webpack 的区别

[Webpack](https://webpack.js.org/) 是目前最为成熟的构建工具，有着活跃的生态，灵活的配置和丰富的功能，但是其最为人诟病的是其性能问题，尤其在一些大型项目上，构建花费的时间可能会达到几分钟甚至几十分钟，性能问题是目前 webpack 最大的短板。因此 Rspack 解决的问题核心就是 Webpack 的性能问题。
Rspack 比 Webpack 快得益于如下几方面

- Rust 语言优势: Rspack 使用 Rust 语言编写， 得益于 Rust 的高性能编译器支持， Rust 编译生成的 Native Code 通常比 JavaScript 性能更为高效。
- 高度并行的架构: Webpack 受限于 JavaScript 对多线程的羸弱支持，导致其很难进行高度的并行化计算，而得益于 Rust 语言的并行化的良好支持， Rspack 采用了高度并行化的架构，如模块图生成，代码生成等阶段，都是采用多线程并行执行，这使得其编译性能随着 CPU 核心数的增长而增长，充分挖掘 CPU 的多核优势。
- 内置大部分的功能: 事实上 Webpack 本身的性能足够高效，但是因为 webpack 本身内置了较少的功能，这使得我们在使用 Webpack 做现代 Web App 开发时，通常需要配合很多的 plugin 和 loader 进行使用，而这些 loader 和 plugin 往往是性能的瓶颈，而 Rspack 虽然支持 loader 和 plugin，但是保证绝大部分常用功能都内置在 Rspack 内，从而减小 JS plugin | loader 导致的低性能和通信开销问题。
- 增量编译: 尽管 Rspack 的全量编译足够高效，但是当项目庞大时，全量的编译仍然难以满足 HMR 的性能要求，因此在 HMR 阶段，我们采用的是更为高效的增量编译策略，从而保证，无论你的项目多大，其 HMR 的开销总是控制在合理范围内。

### 和 Vite 的区别

[Vite](https://vitejs.dev/) 提供了很好的开发者体验，但其在生产构建中对 [Rollup](https://rollupjs.org/) 的依赖面临着与其他基于 JavaScript 的工具链同样的性能问题。 Rollup 相比于 webpack 的一些平衡取舍这里同样适用，如 Rollup 缺失了 webpack 对于拆包的灵活性，即缺失了 [optimization.splitChunks](/config/optimization#optimizationsplitchunks) 提供的很多功能。

### 和 esbuild 的区别

我们在内部进行过大规模的将 [esbuild](https://esbuild.github.io/) 作为通用的 Web App 构建工具的实践，但是遇到如下一些问题：

- 缺乏对 JavaScript HMR 和 增量编译的良好支持，这导致大型项目中其 HMR 性能比较低下
- 拆包策略也非常原始，难以满足业务复杂多变的拆包优化需求。

### 和 Turbopack 的区别

Rspack 和 turbopack 都是采用 Rust 编写的 bundler，且都发挥了 Rust 语言的优势，与 turbopack 不同的是 Rspack 选择了对 Webpack 生态兼容的路线，一方面这些兼容可能会导致带来一定的性能开销，但是在实际的业务落地中，我们发现这些性能开销对于大部分的应用来说是可以接受的，另一方面这些兼容也使得 Rspack 可以更好的与上层的框架和生态进行集成，能够实现业务的渐进式迁移。

### 功能权衡

综合分析上述工具，我们发现不同的工具在不同的场景下都有其优势，但是没有一个工具能够完美的解决所有的问题，本质上是在开发性能，构建性能，生产环境优化，配置灵活性上做权衡，基于此我们创建了 Rspack，希望在这四方面能够达到不错均衡。

<img src={compare} />
